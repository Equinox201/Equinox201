## About Me

I’m Nicolas, a 42 Singapore student transitioning from revenue strategy in hospitality into systems engineering and AI-driven software.

My focus is building strong foundations first:
- Writing memory-safe, predictable C code
- Understanding how software interacts with the OS
- Debugging at the process and file descriptor level
- Designing modular, testable architectures

Beyond 42, I’m building AI-powered systems and exploring the intersection of:
- Systems programming
- Backend architecture
- Intelligent agents
- Performance-critical applications

I value autonomy, clean architecture, and deeply understanding what happens under the hood.
<p align="center">
  <img src="./assets/cub3d_screenshot.png" alt="project badge"/>
</p>


## Connect With Me

- LinkedIn: https://www.linkedin.com/in/nicolas-samarine-781102143
- Email: nick.samarine@yahoo.fr

## Projects

<div align="center">

  <a href="https://github.com/Equinox201/Raycasting_Engine_Cub3D">
    <img src="https://github.com/Equinox201/Raycasting_Engine_Cub3D/blob/main/assets/cub3d_logo.png" width="200"/>
  </a>

  <a href="https://github.com/Equinox201/Unix_Command_Shell">
    <img src="https://github.com/Equinox201/Unix_Command_Shell/blob/main/assets/minishell_logo.png" width="200"/>
  </a>

  <a href="https://github.com/Equinox201/Multi-threading_Dining_Philosophers">
    <img src="https://github.com/Equinox201/Multi-threading_Dining_Philosophers/blob/main/assets/philo_logo.png" width="200"/>
  </a>

  <a href="https://github.com/Equinox201/Tower_of_Hanoi_Sorting_Algorithm">
    <img src="https://github.com/Equinox201/Tower_of_Hanoi_Sorting_Algorithm/blob/main/assets/push_logo.png" width="200"/>
  </a>

  <a href="https://github.com/Equinox201/Escape_the_Dragon_Dungeon">
    <img src="https://raw.githubusercontent.com/Equinox201/Escape_the_Dragon_Dungeon/main/assets/so_long_logo.png" width="200"/>
  </a>

</div>


## Technical Philosophy

I believe strong engineers understand what happens beneath the abstractions.
42’s low-level C curriculum trained me to think in terms of:
- Memory ownership
- File descriptors
- Process lifecycle
- Blocking vs non-blocking I/O
- Explicit error handling

Working under strict constraints (no external libraries, manual memory management, coding norms) forced clarity in architecture and discipline in implementation.

I prioritize:
- Predictable systems over clever hacks
- Clear responsibility boundaries
- Defensive programming
- Reliability under edge cases

My goal is simple: build software that I fully understand - from the OS layer up to intelligent systems.